

### 切片`slice`	

获取`list`或者`tuple`中的部分元素

例如获取数组前两个元素,可以写成`L[0:2]`，如果从索引0开始切片的话还可以省略成`L[:2]`

```python
>>>L=['Michael', 'Sarah', 'Tracy']
>>>L[0:2] # L[:2]
['Michael', 'Sarah']
```

使用负数进行切片，索引`·1`表示元组中最后一个元素，越小的负数表示元组中越前面的数。

```python
>>>L[-2:]
['Sarah', 'Tracy']
```

设定切片的步长

默认情况下，slice步长为1；可以通过修改

例如前10个数中每隔2个取切一次

```python
>>>L[:10:2]   ##第一个0被省略了
```



经典用法

+ 取前10个数
+ 取后10个数
+ 前100个数中每隔5个取一次

```python
>>> L[:10]
>>> L[-10:]
>>>L[:100:5]
```

字符串同样可以当成一个`tuple`,因此可以使用切片来获取子字符串；利用切片实现一个`strip`的功能；去除字符串首尾空白字符

```python
def trim(s)
     while s[:1]==' ':
      s=s[1:]
     while s[-1:]==' ':
      s=s[:-1]
     return s
```

### 迭代

通常在C语言中我们可以循环的遍历数组，在python中对tuple或者list的遍历被称作为迭代；与C语言有差别的是；python中`dict`这类数据类型即使没有数据下标但仍旧是可以进行迭代的。

python2中dict的键的存放顺序可能不是按照list那样排列的；每次取出来的键的顺序可能不一样；

python3中，键应该采样了先存，先取的规则

```python
 d = {'a': 1, 'b': 2, 'c': 3}
for key in d:
    print(key)
```

默认情况下，遍历字典时遍历的是键，也可以使用`dict.values()`函数获取值迭代对象，再使用for循环进行遍历

判断一个对象是否是可迭代的，使用`collections`包中的`Iterable`对象进行判断

```python
from collections import Iterable
isinstance(a,Iterable) #判断a是否可迭代
```

实现类似java中的下标循环，通过使用枚举函数`enumerate`函数，就可以同时获得列表的下标和值

```python
>>> for i, value in enumerate(['A', 'B', 'C']):
...     print(i, value)
...
0 A
1 B
2 C
```

### 列表生成式

常见的用法

+ 快速生成一个list

```python
>>> list(range(1, 11))
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
```

+ 两个list之间实现全排列，python中字符串也可以当成list

```python
>>> [m + n for m in 'ABC' for n in 'XYZ']
['AX', 'AY', 'AZ', 'BX', 'BY', 'BZ', 'CX', 'CY', 'CZ']
```

+ 对生成器进行筛选

  使用if语句进行筛选，并且不能有else；否则筛选就没有意义

+ 对不同元素进行不同处理

  必须同时存在`if...else`;否则得到的原始，不能进行正常，得不到想要的数据



### 列表生成器

不同与列表生成式，列表生成器是可以节约内存的。因为生成式是将所有的元素生成后，再进行迭代；而生成器则是在迭代的过程中根据生成公式不断的推算出后面的元素。

> 生成器保存的是算法，调用`nex(生成器)`函数可以获得一个元素；直到到达最后一个位置时，抛出`StopIteration`错误

同样可以使用for循环来遍历生成器对象，最后也不用管`StopIteration`错误。

将函数变成生成器

> 如果一个函数定义中包含`yield`关键字，那么这个函数就不再是一个普通函数，而是一个generator。并且generator和函数的执行流程不一样。函数是顺序执行，遇到`return`语句或者最后一行函数语句就返回。而变成generator的函数，在每次调用`next()`的时候执行，遇到`yield`语句返回，再次执行时从上次返回的`yield`语句处继续执行。



